#!/usr/bin/env python
"""
This is the user's entry-point for the seq2science pipeline.
"""
import sys
import argparse
import os
import shutil
import json
import webbrowser
import re

from snakemake import snakemake


__version__ = "0.0.0"


def main():
    # set helpful paths
    base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
    workflows_dir = os.path.join(base_dir, "workflows")

    parser = seq2science_parser(workflows_dir)
    args = parser.parse_args()

    # turn config path into absolute path
    if args.command in ["init", "run"]:
        config_path = args.config
        if not os.path.isabs(args.config):
            config_path = os.path.join(os.getcwd(), args.config)

    # now run the command
    if args.command == "init":
        _init(args, workflows_dir, config_path)
    elif args.command == "run":
        _run(args, base_dir, workflows_dir, config_path)
    elif args.command == "docs":
        _docs()


def seq2science_parser(workflows_dir):
    """
    Make the seq2science parser.
    """
    # setup the parser
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-v", "--version", action="version", version=f"seq2science: v{__version__}"
    )
    subparsers = parser.add_subparsers(dest="command")
    subparsers.required = True
    init = subparsers.add_parser(
        "init",
        description="Each workflow requires a configuration and samples file to run. "
        'Running "seq2science init {workflow}" initialises a default '
        "configuration and samples file for the specific workflow.",
        help="Initialise a workflow with an example config and samples file.",
    )
    run = subparsers.add_parser(
        "run",
        description="Run a complete workflow. This requires that a config and samples file "
        "are present. These files can be ",
        help="Run a complete workflow.",
    )
    docs = subparsers.add_parser(
        "docs",
        description="The docs command tries to open your browser and open the docs' webpage, "
        "if that didn't work it prints the url.",
        help="Take me to the docs!",
    )

    # both init and run can use all workflows
    for subparser in [init, run]:
        subparser.add_argument("workflow", choices=os.listdir(workflows_dir))

    # setup init arguments
    init.add_argument(
        "--dir",
        default=".",
        metavar="PATH",
        help="The path to the directory where to initialise the config and samples files.",
    )

    # setup run arguments
    def minimum_cores(value):
        ivalue = int(value)
        if ivalue < 2:
            raise argparse.ArgumentTypeError(f"Please provide 2 or more cores.")
        return ivalue

    run.add_argument(
        "-c",
        "--config",
        default="config.yaml",
        metavar="FILE",
        help="The path to the config file.",
    )
    run.add_argument(
        "--cores",
        required=True,
        metavar="N",
        type=minimum_cores,
        help="Use at most N cores in parallel.",
    )
    run.add_argument(
        "-n", "--dryrun",
        help="Do not execute anything, and display what would be done.",
        action='store_true'
    )
    run.add_argument(
        "--unlock",
        help="Remove a lock on the working directory.",
        action='store_true'
    )
    run.add_argument(
        "--snakemakeOptions",
        nargs="+",
        action=_StoreDictKeyPair,
        metavar="KEY=VAL",
        help="Extra arguments to pass along to snakemake. An example could be seq2science run "
        "{workflow} --cores 10 --snakemakeOptions resources={mem_gb:100} local_cores=3. Take a look at the snakemake API for a "
        "list of all possible options: https://snakemake.readthedocs.io/en/latest/api_reference/snakemake.html",
    )

    return parser


def _init(args, workflows_dir, config_path):
    """
    Initialise a config.yaml and samples.tsv from the relevant workflow.
    """
    for file in ["samples.tsv", "config.yaml"]:
        src = os.path.join(workflows_dir, args.workflow, file)
        dest = os.path.join(os.path.dirname(config_path), file)

        copy_file = True
        if os.path.exists(dest):
            choices = {"yes": True, "y": True, "no": False, "n": False}

            sys.stdout.write(
                f"File: {dest} already exists. Do you want to overwrite it? (yes/no) "
            )
            while True:
                choice = input().lower()
                if choice in choices:
                    copy_file = choices[choice]
                    break
                else:
                    print("Please respond with yes (y) or no (n).")

        if copy_file:
            shutil.copyfile(src, dest)


def _run(args, base_dir, workflows_dir, config_path):
    """
    Run a complete workflow.
    """
    if not os.path.exists(config_path):
        sys.stdout.write(
            f"The config file: {config_path} does not exist.\nProvide a path to the config file with "
            f"--config or if you do not have a config file run:\n"
            f"seq2science init {args.workflow}\n"
        )
        sys.exit(1)

    exit_code = snakemake(
        snakefile=os.path.join(workflows_dir, args.workflow, "Snakefile"),
        configfiles=[config_path],
        config={"rule_dir": os.path.join(base_dir, "rules")},
        cores=args.cores,
        use_conda=True,
        conda_prefix=os.path.join(base_dir, ".snakemake"),
        dryrun=args.dryrun,
        **args.snakemakeOptions
    )
    sys.exit(exit_code)


def _docs():
    """
    Open a webbrowser to the docs, if that fails simply print the url.
    """
    url = "https://github.com/vanheeringen-lab/snakemake-workflows/wiki"
    if not webbrowser.open(url):
        print(url)


class _StoreDictKeyPair(argparse.Action):
    """
    Class that allows us to take key=value pairs from command-line to feed to
    snakemake. Solution taken from:
    https://stackoverflow.com/questions/29986185/python-argparse-dict-arg
    """

    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        self._nargs = nargs
        super(_StoreDictKeyPair, self).__init__(
            option_strings, dest, nargs=nargs, **kwargs
        )

    def __call__(self, parser, namespace, values, option_string=None):
        my_dict = {}
        for kv in values:
            k, v = kv.split("=")
            if v[0] == "{" and v[-1] == "}":
                pairs = list(filter(None, re.split('{|:| |}', v)))
                assert len(pairs) % 2 == 0
                v = {pairs[i]: pairs[i+1] for i in range(0, len(pairs), 2)}
                v = {k: int(v) if v.isdigit() else v for k, v in v.items()}
            try:
                my_dict[k] = int(v)
            except:
                my_dict[k] = v

        setattr(namespace, self.dest, my_dict)


if __name__ == "__main__":
    main()
